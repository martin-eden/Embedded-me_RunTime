( Sleep vs Delay

  There are two common names for do-nothing function: "sleep" and
  "delay". For me they are quite different in details.

  Sleep
    - you wanna save battery
    - you have nothing to do now
    - you gonna sleep for a long time (seconds)
    - you've set-up signals that will wake you

  Delay
    - you want high temporal precision
    - you're doing important timing job right now
    - stage is not long (sub-seconds)
    - you've disabled all interrupts

) 2025-08-15, 2025-10-10

(
  Wrote parallel implementation of time tracking.
  Almost same code, almost same size -- near 220 lines.

  Looks like this module can't be made simpler.
) 2025-12-10

( Comments I don't yet dare to delete

  /*
    This implementation uses hardware counter 3 (named TC2 in datasheet).

    Main reason for this are interrupts priorities: counter 3 interrupts
    are served before other counters interrupts. In interrupt handler
    you want to have correct time.

    Also it can tick from external signal and stay alive in most sleep
    modes. And has best range of system clock scaling. Which makes me
    think it's suitable for run time tracking and designed for event
    planning.
  */

  /*
    Arduino framework uses:

      * Counter 1 for time tracking

        See <wiring.c>. I don't know why. Ask David Mellis from 2005.

      * Counter 3 for tone() function

        See <Tone.cpp>.

    Our framework uses:

      * Counter 1 for wave generation. See [me_FrequencyGenerator]
      * Counter 2 for signal capture. See [me_DigitalSignalRecorder]
      * Counter 3 for time tracking. See [me_RunTime]
  */

  /*
    Counter used here is simple thing

    It advances from from 0 to 255 every "tick". "Tick" is scaled
    system clock. After 255 it goes to 0 and raises "overflow"
    interrupt flag.
  */

) 2025-12-10

(
  Modes nomenclature

  Datasheet lists several (stupid) mode names: "Normal", "CTC",
  "Fast PWM", "Phase correct PWM" and finally "Phase and frequency
  correct PWM".

  I have no idea how ".. and frequency" mode differs from "phase" mode.
  But for other's below is my explanation.

  (Examples are for 8-bit counters. For 16-bit counters use 0xFFFF
  where appropriate.)

  * Single-slope

    | for i = 1 to N

    * Normal

      | > ()
      | for i = 1 to 0xFF
      | Event_Done()

    * CTC ((c)lear (t)imer on (c)ompare match)

      | > (N)
      | for i = 1 to N
      | Event_Done()

    * Fast PWM

      | > (M N)
      | for i = 1 to N
      |   if (i == M)
      |     Event_PassedPoint()
      | Event_Done()

  * Dual-slope

    | for i = 1 to N
    | for i = N - 1 downto 1

    * Phase correct PWM

      | > (M N)
      | for i = 1 to N
      |   if (i == M)
      |     Event_PassedPoint(Up)
      | for i = N - 1 downto 1
      |   if (i == M)
      |     Event_PassedPoint(Down)
      | Event_Done()

  "Events" here are hardware actions on counter's pin. They can be
  configured to "set", "clear", "toggle" and "nothing" on output pin's
  digital value.

  Also "events" set interrupt flags, so your code can be called.

  That's not complete explanation. Loop limit values can be changed
  at runtime. And how many iterations will actually be done depends
  of new and current loop limit value. But that's too specific details
  for those who wish rugged PWM emitter that allows dynamic duty cycle
  (and maybe even frequency) changes without messing up current wave.

) 2026-01-10
